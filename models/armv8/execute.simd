// ----------------------------------------------------------------------------
// C4.6.1			Advanced SIMD across lanes
// ----------------------------------------------------------------------------

execute(saddlv)
{
	not_implemented();
}

execute(smaxv)
{
	if (read_vector_reg32(1) == 5) {
		//write_vector_reg32(1, 8);
		not_implemented();
	}
}

execute(sminv)
{
	not_implemented();
}

execute(addv)
{
	uint64 total = 0;
	
	switch (inst.arrangement) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		
		for (uint8 i = 0; i < 8; i++) {
			total += rn[i];
		}
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		
		for (uint8 i = 0; i < 16; i++) {
			total += rn[i];
		}
		break;
	}
	case 2: {	// 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		
		for (uint8 i = 0; i < 4; i++) {
			total += rn[i];
		}
		break;
	}
	case 3: {	// 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		
		for (uint8 i = 0; i < 8; i++) {
			total += rn[i];
		}
		break;
	}
	case 4: {	// 2s
		trap();
		break;
	}
	case 5: {	// 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		
		for (uint8 i = 0; i < 4; i++) {
			total += rn[i];
		}
		break;
	}
	case 6: {	// 2d
		trap();
		break;
	}
	default: {
		trap();
		break;
	}
	}
	
	switch (inst.size) {
	case 0: {
		write_vector_reg8(inst.rd, (uint8)total);
		break;
	}
	case 1: {
		write_vector_reg16(inst.rd, (uint16)total);
		break;
	}
	case 2: {
		write_vector_reg32(inst.rd, (uint32)total);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(uaddlv)
{
	not_implemented();
}

execute(umaxv)
{
	not_implemented();
}

execute(uminv)
{
	not_implemented();
}

execute(fmaxnmv)
{
	not_implemented();
}

execute(fmaxv)
{
	not_implemented();
}

execute(fminnmv)
{
	not_implemented();
}

execute(fminv)
{
	not_implemented();
}

// ----------------------------------------------------------------------------
// C4.6.1			Advanced SIMD across lanes
// ----------------------------------------------------------------------------
execute(dup_elem)
{
	not_implemented();
}

execute(dup_gen)
{
	uint64 element = read_gpr(inst.width==64, inst.rn);
	
	uint64 rlo;
	switch (inst.arrangement) {
	case 0: {	// 8B
		element &= 0xff;
		rlo = element | (element << 8) | (element << 16) | (element << 24) | (element << 32) | (element << 40) | (element << 48) | (element << 56);
		break;
	}
	case 1: {	// 16B
		element &= 0xff;
		rlo = element | (element << 8) | (element << 16) | (element << 24) | (element << 32) | (element << 40) | (element << 48) | (element << 56);
		break;
	}
	case 2: {	// 4H
		element &= 0xffff;
		rlo = element | (element << 16) | (element << 32) | (element << 48);
		break;
	}
	case 3: {	// 8H
		element &= 0xffff;
		rlo = element | (element << 16) | (element << 32) | (element << 48);
		break;
	}
	case 4: {	// 2S
		element &= 0xffffffff;
		rlo = element | (element << 32);
		break;
	}
	case 5: {	// 4S
		element &= 0xffffffff;
		rlo = element | (element << 32);
		break;
	}
	case 6: {	// 2D
		rlo = element;
		break;
	}
	default: {
		trap();
		break;
	}
	}
	
	if (inst.Q == 1) {
		write_vector_reg128(inst.rd, rlo, rlo);
	} else {
		write_vector_reg64(inst.rd, rlo);
	}
}

execute(smov)
{
	not_implemented();
}

execute(umov)
{
	// arrg, width, sz
	uint8 index = (inst.imm5 & 0x1f) >> (inst.size+1);

	uint64 rnl;
	uint64 rnh;
	read_vector_reg128(inst.rn, rnl, rnh);
		
	uint64 value;
	switch (inst.size) {
	case 0: {
		if (index < 8) {
			/*uint8[8] v;
			v = read_register_bank(VB8L, inst.rn);
			value = (uint64)v[index];*/
		
			value = rnl >> (index * 8);
		} else {
			value = rnh >> ((index - 8) * 8);
		}
		value &= 0xff;
		break;
	}
	case 1: {
		if (index < 4) {
			value = rnl >> (index * 16);
		} else {
			value = rnh >> ((index - 4) * 16);
		}
		value &= 0xffff;
		break;
	}
	case 2: {
		if (index < 2) {
			value = rnl >> (index * 32);
		} else {
			value = rnh >> ((index - 2) * 32);
		}
		value &= 0xffffffff;
		break;
	}
	case 3: {
		if (index == 0) {
			value = rnl+0;
		} else {
			value = rnh+0;
		}
		break;
	}
	}
	
	write_gpr(inst.width == 64, inst.rd, value);
}

execute(ins_gen)
{
	not_implemented();
}

execute(ins_elem)
{
	not_implemented();
}

helper void store_vector_pair(uint8 size, uint8 rt1, uint8 rt2, uint64 addr)
{
	uint8 offset = 1 << size;
	store_vector(size, rt1, addr);
	store_vector(size, rt2, addr+offset);
	return;
}

helper void load_vector_pair(uint8 size, uint8 rt1, uint8 rt2, uint64 addr)
{
	uint8 offset = 1 << size;
	load_vector(size, rt1, addr);
	load_vector(size, rt2, addr+offset);
	return;
}

execute(stp_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	store_vector_pair(inst.opc+2, inst.rt, inst.rt2, addr);
}

execute(stpi_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	if (inst.P) {
		addr += inst.immu64;
	}
	
	store_vector_pair(inst.opc + 2, inst.rt, inst.rt2, addr);
	
	if (!inst.P) {
		addr += inst.immu64;
	}
	
	write_gpr_sp(1, inst.rn, addr);
}

execute(ldp_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	load_vector_pair(inst.opc + 2, inst.rt, inst.rt2, addr);
}

execute(ldpi_simd)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	if (inst.P) {
		addr += inst.immu64;
	}
	
	load_vector_pair(inst.opc + 2, inst.rt, inst.rt2, addr);
	
	if (!inst.P) {
		addr += inst.immu64;
	}
	
	write_gpr_sp(1, inst.rn, addr);
}

// ----------------------------------------------------------------------------
// C4.6.10			Advanced SIMD scalar three same
// C4.6.16			Advanced SIMD three same
// ----------------------------------------------------------------------------
execute(add_vector)
{
	switch (inst.arrangement) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint8[8] rd = rn + rm;
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint8[16] rd = rn + rm;
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	case 2: {	// 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[4] rm = read_register_bank(VB4H, inst.rm);
		
		uint16[4] rd = rn + rm;
		write_register_bank(VB4H, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 3: {	// 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rm);
		
		uint16[8] rd = rn + rm;
		write_register_bank(VB8H, inst.rd, rd);
		
		break;
	}
	case 4: {	// 2s
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[2] rm = read_register_bank(VB2S, inst.rm);
		
		uint32[2] rd = rn + rm;
		write_register_bank(VB2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 5: {	// 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rm);
		
		uint32[4] rd = rn + rm;
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 6: {	// 2d
		uint64[2] rn = read_register_bank(VB2D, inst.rn);
		uint64[2] rm = read_register_bank(VB2D, inst.rm);
		
		uint64[2] rd = rn + rm;
		write_register_bank(VB2D, inst.rd, rd);
		
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(addp_vector)
{
	switch (inst.arrangement) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint8[8] rd = (uint8)0;
		for (uint8 ia = 0; ia < 4; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 4; ib++) {
			rd[ib+4] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint8[16] rd = (uint8)0;
		for (uint16 ia = 0; ia < 8; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint16 ib = 0; ib < 8; ib++) {
			rd[ib+8] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	case 2: {	// 4h
		uint16[4] rn = read_register_bank(VB4H, inst.rn);
		uint16[4] rm = read_register_bank(VB4H, inst.rm);
		
		uint16[4] rd = (uint16)0;
		for (uint8 ia = 0; ia < 2; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 2; ib++) {
			rd[ib+2] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB4H, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 3: {	// 8h
		uint16[8] rn = read_register_bank(VB8H, inst.rn);
		uint16[8] rm = read_register_bank(VB8H, inst.rm);
		
		uint16[8] rd = (uint16)0;
		for (uint8 ia = 0; ia < 4; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 4; ib++) {
			rd[ib+4] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		write_register_bank(VB8H, inst.rd, rd);
		
		break;
	}
	case 4: {	// 2s
		uint32[2] rn = read_register_bank(VB2S, inst.rn);
		uint32[2] rm = read_register_bank(VB2S, inst.rm);
		
		uint32[2] rd = (uint32)0;
		for (uint8 ia = 0; ia < 1; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 1; ib++) {
			rd[ib+1] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB2S, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 5: {	// 4s
		uint32[4] rn = read_register_bank(VB4S, inst.rn);
		uint32[4] rm = read_register_bank(VB4S, inst.rm);
		
		uint32[4] rd = (uint32)0;
		for (uint8 ia = 0; ia < 2; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia * 2)+1];
		}
		
		for (uint8 ib = 0; ib < 2; ib++) {
			rd[ib+2] = rm[ib * 2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB4S, inst.rd, rd);
		break;
	}
	case 6: {	// 2d
		uint64[2] rn = read_register_bank(VB2D, inst.rn);
		uint64[2] rm = read_register_bank(VB2D, inst.rm);
		
		uint64[2] rd = (uint64)0;
		for (uint8 ia = 0; ia < 1; ia++) {
			rd[ia] = rn[ia * 2] + rn[(ia *2)+1];
		}
		
		for (uint8 ib = 0; ib < 1; ib++) {
			rd[ib+1] = rm[ib*2] + rm[(ib * 2)+1];
		}
		
		write_register_bank(VB2D, inst.rd, rd);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(and_vector)
{
	switch (inst.Q) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint8[8] rd = rn & rm;
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint8[16] rd = rn & rm;
		
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(orr_vector)
{
	switch (inst.Q) {
	case 0: {	// 8b
		uint8[8] rn = read_register_bank(VB8B, inst.rn);
		uint8[8] rm = read_register_bank(VB8B, inst.rm);
		
		uint8[8] rd = rn | rm;
		write_register_bank(VB8B, inst.rd, rd);
		write_register_bank(VBH, inst.rd, 0);
		
		break;
	}
	case 1: {	// 16b
		uint8[16] rn = read_register_bank(VB16B, inst.rn);
		uint8[16] rm = read_register_bank(VB16B, inst.rm);
		
		uint8[16] rd = rn | rm;
		
		write_register_bank(VB16B, inst.rd, rd);
		break;
	}
	default: {
		trap();
		break;
	}
	}
}

execute(cmeq_reg)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		uint64 rm = read_vector_reg64(inst.rm);
		
		if (rn == rm) {
			write_vector_reg64(inst.rd, 0xffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			uint8[8] rm = read_register_bank(VB8B, inst.rm);
			
			uint8[8] rd = rn == rm;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			uint8[16] rm = read_register_bank(VB16B, inst.rm);
			
			uint8[16] rd = rn == rm;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			uint16[4] rm = read_register_bank(VB4H, inst.rm);
			
			uint16[4] rd = rn == rm;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			uint16[8] rm = read_register_bank(VB8H, inst.rm);
			
			uint16[8] rd = rn == rm;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			uint32[2] rm = read_register_bank(VB2S, inst.rm);
			
			uint32[2] rd = rn == rm;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			uint32[4] rm = read_register_bank(VB4S, inst.rm);
			
			uint32[4] rd = rn == rm;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			uint64[2] rm = read_register_bank(VB2D, inst.rm);
			
			uint64[2] rd = rn == rm;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(fabd)
{
	if (inst.SCALAR) {
		if (inst.size == 2) {
			float rn = read_float_reg32(inst.rn);
			float rm = read_float_reg32(inst.rm);
		
			write_float_reg32(inst.rd, __builtin_fabs32(rn - rm));
		} else if (inst.size == 3) {
			double rn = read_float_reg64(inst.rn);
			double rm = read_float_reg64(inst.rm);
		
			write_float_reg64(inst.rd, __builtin_fabs64(rn - rm));
		}
	} else {
		trap();
	}
}

execute(cmeq_zero)
{
	if (inst.SCALAR) {
		uint64 rn = read_vector_reg64(inst.rn);
		
		if (rn == 0) {
			write_vector_reg64(inst.rd, 0xffffffff);
		} else {
			write_vector_reg64(inst.rd, 0);
		}
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			
			uint8[8] rd = rn == (uint8)0;
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			
			uint8[16] rd = rn == (uint8)0;
			write_register_bank(VB16B, inst.rd, rd);
			
			break;
		}
		case 2: {	// 4h
			uint16[4] rn = read_register_bank(VB4H, inst.rn);
			
			uint16[4] rd = rn == (uint16)0;
			write_register_bank(VB4H, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 3: {	// 8h
			uint16[8] rn = read_register_bank(VB8H, inst.rn);
			
			uint16[8] rd = rn == (uint16)0;
			
			write_register_bank(VB8H, inst.rd, rd);
			break;
		}
		case 4: {	// 2s
			uint32[2] rn = read_register_bank(VB2S, inst.rn);
			
			uint32[2] rd = rn == (uint32)0;
			write_register_bank(VB2S, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 5: {	// 4s
			uint32[4] rn = read_register_bank(VB4S, inst.rn);
			
			uint32[4] rd = rn == (uint32)0;
			
			write_register_bank(VB4S, inst.rd, rd);
			break;
		}
		case 6: {	// 2d
			uint64[2] rn = read_register_bank(VB2D, inst.rn);
			
			uint64[2] rd = rn == (uint64)0;
			
			write_register_bank(VB2D, inst.rd, rd);
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(cnt)
{
	if (inst.SCALAR) {
		trap();
	} else {
		switch (inst.arrangement) {
		case 0: {	// 8b
			uint8[8] rn = read_register_bank(VB8B, inst.rn);
			
			uint8[8] rd = (uint8)0;
			for (uint8 i = 0; i < 8; i++) {
				rd[i] = (uint8)__builtin_popcount(rn[i]);
			}
			
			write_register_bank(VB8B, inst.rd, rd);
			write_register_bank(VBH, inst.rd, 0);
			
			break;
		}
		case 1: {	// 16b
			uint8[16] rn = read_register_bank(VB16B, inst.rn);
			
			uint8[16] rd = (uint8)0;
			for (uint8 i = 0; i < 16; i++) {
				rd[i] = (uint8)__builtin_popcount(rn[i]);
			}
			
			write_register_bank(VB16B, inst.rd, rd);
			break;
		}
		case 2: {	// 4h
			trap();
			break;
		}
		case 3: {	// 8h
			trap();
			break;
		}
		case 4: {	// 2s
			trap();
			break;
		}
		case 5: {	// 4s
			trap();
			break;
		}
		case 6: {	// 2d
			trap();
			break;
		}
		default: {
			trap();
			break;
		}
		}
	}
}

execute(ld1)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(ld2)
{
	not_implemented();
}

execute(ld3)
{
	not_implemented();
}

execute(ld4)
{
	not_implemented();
}

execute(st1)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			store_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
}

execute(st2)
{
	not_implemented();
}

execute(st3)
{
	not_implemented();
}

execute(st4)
{
	not_implemented();
}

execute(ld1pi)
{
	uint64 address = read_gpr_sp(1, inst.rn);
	
	for (uint8 rt = 0; rt < inst.regcnt; rt++) {
		for (uint8 lane = 0; lane < inst.elemcnt; lane++) {
			load_vector_lane(inst.arrangement, inst.rt + rt, lane, address);
			address += inst.elemsize;
		}
	}
	
	if (inst.rm != 31) {
		address = read_gpr(1, inst.rm);
	}
	
	write_gpr_sp(1, inst.rn, address);
}

execute(ld2pi)
{
	not_implemented();
}

execute(ld3pi)
{
	not_implemented();
}

execute(ld4pi)
{
	not_implemented();
}

execute(st1pi)
{
	not_implemented();
}

execute(st2pi)
{
	not_implemented();
}

execute(st3pi)
{
	not_implemented();
}

execute(st4pi)
{
	not_implemented();
}

helper void store_vector(uint8 size, uint8 rt, uint64 addr)
{
	switch (size) {
	case 0: {
		// 8-bit
		uint8 value = read_vector_reg8(rt);
		mem_write_8(Data, addr, value);
		break;
	}
	case 1: {
		// 16-bit
		uint16 value = read_vector_reg16(rt);
		mem_write_16(Data, addr, value);
		break;
	}
	case 2: {
		// 32-bit
		uint32 value = read_vector_reg32(rt);
		mem_write_32(Data, addr, value);
		break;
	}
	case 3: {
		// 64-bit
		uint64 value = read_vector_reg64(rt);
		mem_write_64(Data, addr, value);
		break;
	}
	case 4: {
		// 128-bit
		uint64 vl;
		uint64 vh;
		read_vector_reg128(rt, vl, vh);
		mem_write_64(Data, addr, vl);
		mem_write_64(Data, addr+8, vh);
		break;
	}
	}
	return;
}

helper void load_vector(uint8 size, uint8 rt, uint64 addr)
{
	switch (size) {
	case 0: {
		// 8-bit
		uint8 value;
		mem_read_8(Data, addr, value);
		write_vector_reg8(rt, value);
		break;
	}
	case 1: {
		// 16-bit
		uint16 value;
		mem_read_16(Data, addr, value);
		write_vector_reg16(rt, value);
		break;
	}
	case 2: {
		// 32-bit
		uint32 value;
		mem_read_32(Data, addr, value);
		write_vector_reg32(rt, value);
		break;
	}
	case 3: {
		// 64-bit
		uint64 value;
		mem_read_64(Data, addr, value);
		write_vector_reg64(rt, value);
		break;
	}
	case 4: {
		// 128-bit
		uint64 vl;
		uint64 vh;
		mem_read_64(Data, addr, vl);
		mem_read_64(Data, addr+8, vh);
		write_vector_reg128(rt, vl, vh);
		break;
	}
	}
	return;
}

helper void load_vector_lane(uint8 arrg, uint8 rt, uint8 lane, uint64 addr)
{
	switch (arrg) {
	case 0: {	// 8b
		uint8 mem_value;
		mem_read_8(Data, addr, mem_value);

		uint8[8] vector_value = read_register_bank(VB8B, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB8B, rt, vector_value);
		break;
	}
	case 1: {	// 16b
		uint8 mem_value;
		mem_read_8(Data, addr, mem_value);

		uint8[16] vector_value = read_register_bank(VB16B, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB16B, rt, vector_value);
		break;
	}
	case 2: {	// 4h
		uint16 mem_value;
		mem_read_16(Data, addr, mem_value);

		uint16[4] vector_value = read_register_bank(VB4H, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB4H, rt, vector_value);
		break;
	}
	case 3: {	// 8h
		uint16 mem_value;
		mem_read_16(Data, addr, mem_value);

		uint16[8] vector_value = read_register_bank(VB8H, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB8H, rt, vector_value);
		break;
	}
	case 4: {	// 2s
		uint32 mem_value;
		mem_read_32(Data, addr, mem_value);

		uint32[2] vector_value = read_register_bank(VB2S, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB2S, rt, vector_value);
		break;
	}
	case 5: {	// 4s
		uint32 mem_value;
		mem_read_32(Data, addr, mem_value);

		uint32[4] vector_value = read_register_bank(VB4S, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB4S, rt, vector_value);
		break;
	}
	case 6: {	// 2d
		uint64 mem_value;
		mem_read_64(Data, addr, mem_value);

		uint64[2] vector_value = read_register_bank(VB2D, rt);
		vector_value[lane] = mem_value;
		write_register_bank(VB2D, rt, vector_value);
		break;
	}
	default: {
		trap();
		break;
	}
	}
	return;
}

helper void store_vector_lane(uint8 arrg, uint8 rt, uint8 lane, uint64 addr)
{
	switch (arrg) {
	case 0: {	// 8b
		uint8[8] vector_value = read_register_bank(VB8B, rt);
		mem_write_8(Data, addr, vector_value[lane]);
		break;
	}
	case 1: {	// 16b
		uint8[16] vector_value = read_register_bank(VB16B, rt);
		mem_write_8(Data, addr, vector_value[lane]);
		break;
	}
	case 2: {	// 4h
		uint16[4] vector_value = read_register_bank(VB4H, rt);
		mem_write_16(Data, addr, vector_value[lane]);
		break;
	}
	case 3: {	// 8h
		uint16[8] vector_value = read_register_bank(VB8H, rt);
		mem_write_16(Data, addr, vector_value[lane]);
		break;
	}
	case 4: {	// 2s
		uint32[2] vector_value = read_register_bank(VB2S, rt);
		mem_write_32(Data, addr, vector_value[lane]);
		break;
	}
	case 5: {	// 4s
		uint32[4] vector_value = read_register_bank(VB4S, rt);
		mem_write_32(Data, addr, vector_value[lane]);
		break;
	}
	case 6: {	// 2d
		uint64[2] vector_value = read_register_bank(VB2D, rt);
		mem_write_64(Data, addr, vector_value[lane]);
		break;
	}
	default: {
		trap();
		break;
	}
	}
	return;
}

execute(vstr)
{
	uint64 addr = read_gpr_sp(1, inst.rn) + inst.immu64;
	store_vector(((inst.size == 0) ? ((inst.opc == 0) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(vldr)
{
	uint64 addr = read_gpr_sp(1, inst.rn) + inst.immu64;
	load_vector(((inst.size == 0) ? ((inst.opc == 0) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(vstur)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	store_vector(((inst.size == 0) ? ((inst.opc == 0) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(vldur)
{
	uint64 addr = read_gpr_sp(1, inst.rn);
	addr += inst.imms64;
	
	load_vector(((inst.size == 0) ? ((inst.opc == 0) ? ((uint8)0) : ((uint8)4)) : ((uint8)inst.size)), inst.rt, addr);
}

execute(ldr_lit_simd)
{
	uint64 address = read_pc() + inst.label;
	
	switch (inst.opc) {
	case 0: {
		load_vector(2, inst.rt, address);
		break;
	}
	case 1: {
		load_vector(3, inst.rt, address);
		break;
	}
	case 2: {
		load_vector(4, inst.rt, address);
		break;
	}
	default: {
		trap();
	}
	}
}

execute(ldr_reg_simd)
{
	uint8 shift = (inst.S == 0) ? (uint8)0 : (uint8)inst.size;
	
	uint64 rm;
	if (inst.option0 == 0 && inst.option21 == 1) {			// UXTW
		rm = extend_reg(0, inst.rm, 2, shift);
	} else if (inst.option0 == 0 && inst.option21 == 3) {	// SXTW
		rm = extend_reg(0, inst.rm, 6, shift);
	} else if (inst.option0 == 1 && inst.option21 == 1) {	// LSL (UXTX)
		rm = extend_reg(1, inst.rm, 3, shift);
	} else if (inst.option0 == 1 && inst.option21 == 3) {	// SXTX
		rm = extend_reg(1, inst.rm, 7, shift);
	} else {
		rm = 0;
		trap();
	}
	
	uint64 address = read_gpr_sp(1, inst.rn) + rm;
	
	if (inst.size == 0) {
		if (inst.X == 1) {
			// 128
			load_vector(4, inst.rt, address);
		} else {
			// 8
			load_vector(0, inst.rt, address);
		}
	} else if (inst.size == 1) {
		// 16
		load_vector(1, inst.rt, address);
	} else if (inst.size == 2) {
		// 32
		load_vector(2, inst.rt, address);
	} else if (inst.size == 3) {
		// 64
		load_vector(3, inst.rt, address);
	}
}

execute(str_reg_simd)
{
	uint8 shift = (inst.S == 0) ? (uint8)0 : (uint8)inst.size;
	
	uint64 rm;
	if (inst.option0 == 0 && inst.option21 == 1) {			// UXTW
		rm = extend_reg(0, inst.rm, 2, shift);
	} else if (inst.option0 == 0 && inst.option21 == 3) {	// SXTW
		rm = extend_reg(0, inst.rm, 6, shift);
	} else if (inst.option0 == 1 && inst.option21 == 1) {	// LSL (UXTX)
		rm = extend_reg(1, inst.rm, 3, shift);
	} else if (inst.option0 == 1 && inst.option21 == 3) {	// SXTX
		rm = extend_reg(1, inst.rm, 7, shift);
	} else {
		rm = 0;
		trap();
	}
	
	uint64 address = read_gpr_sp(1, inst.rn) + rm;
	
	if (inst.size == 0) {
		if (inst.X == 1) {
			// 128
			store_vector(4, inst.rt, address);
		} else {
			// 8
			store_vector(0, inst.rt, address);
		}
	} else if (inst.size == 1) {
		// 16
		store_vector(1, inst.rt, address);
	} else if (inst.size == 2) {
		// 32
		store_vector(2, inst.rt, address);
	} else if (inst.size == 3) {
		// 64
		store_vector(3, inst.rt, address);
	}
}

execute(fmov)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, read_float_reg32(inst.rn));
	} else {
		write_float_reg64(inst.rd, read_float_reg64(inst.rn));
	}
}

execute(fneg)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, -read_float_reg32(inst.rn));
	} else {
		write_float_reg64(inst.rd, -read_float_reg64(inst.rn));
	}
}

execute(fmov_gen)
{
	if (inst.sf == 0 && inst.type == 0 && inst.rmode == 0 && inst.opcode == 7) {
		// 32-bit to single-precision
		write_register_bank(VS, inst.rd, read_gpr(0, inst.rn));
		write_register_bank(FSH, inst.rd, 0);
		write_register_bank(VBH, inst.rd, 0);
	} else if (inst.sf == 0 && inst.type == 0 && inst.rmode == 0 && inst.opcode == 6) {
		// Single-precision to 32-bit
		write_gpr(0, inst.rd, read_register_bank(VS, inst.rn));
	} else if (inst.sf == 1 && inst.type == 1 && inst.rmode == 0 && inst.opcode == 7) {
		// 64-bit to double-precision
		write_register_bank(VD, inst.rd, read_gpr(1, inst.rn));
		write_register_bank(VBH, inst.rd, 0);
	} else if (inst.sf == 1 && inst.type == 2 && inst.rmode == 1 && inst.opcode == 7) {
		// 64-bit to top-half of 128-bit
		write_register_bank(VBH, inst.rd, read_gpr(1, inst.rn));
	} else if (inst.sf == 1 && inst.type == 1 && inst.rmode == 0 && inst.opcode == 6) {
		// Double-precision to 64-bit
		write_gpr(1, inst.rd, read_register_bank(VD, inst.rn));
	} else if (inst.sf == 1 && inst.type == 2 && inst.rmode == 1 && inst.opcode == 6) {
		// Top-half of 128-bit to 64-bit
		write_gpr(1, inst.rd, read_register_bank(VBH, inst.rn));
	} else {
		trap();
	}
}

execute(fadd)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n + m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n + m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fsub)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n - m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n - m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fmul)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n * m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n * m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fnmul)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = -(n * m);
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = -(n * m);
		write_float_reg64(inst.rd, result);
	}	
}

execute(fdiv)
{
	if (inst.type == 0) {
		// f32
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);
		
		float result = n / m;
		write_float_reg32(inst.rd, result);
	} else {
		// f64
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);
		
		double result = n / m;
		write_float_reg64(inst.rd, result);
	}	
}

execute(fm)
{
	if (inst.type == 0) {
		// f32
		float a = read_float_reg32(inst.ra);
		float n = read_float_reg32(inst.rn);
		float m = read_float_reg32(inst.rm);

		if (inst.o0 == 0) {
			float result = __builtin_fma32(n, m, a);	// (n * m) + a;
			write_float_reg32(inst.rd, result);
		} else {
			float result = __builtin_fma32(-n, m, a);	// (-n * m) + a;
			write_float_reg32(inst.rd, result);
		}
	} else {
		// f64
		double a = read_float_reg64(inst.ra);
		double n = read_float_reg64(inst.rn);
		double m = read_float_reg64(inst.rm);

		if (inst.o0 == 0) {
			double result = __builtin_fma64(n, m, a);	// (n * m) + a;
			write_float_reg64(inst.rd, result);
		} else {
			double result = __builtin_fma64(-n, m, a);	// (-n * m) + a;
			write_float_reg64(inst.rd, result);
		}
	}
}

execute(fnm)
{
	if (inst.type == 0) {
		// f32
		double a = -(double)read_float_reg32(inst.ra);
		double n = -(double)read_float_reg32(inst.rn);
		double m = (double)read_float_reg32(inst.rm);

		if (inst.o0 == 0) {
			float result = (n * m) + a;
			write_float_reg32(inst.rd, result);
		} else {
			float result = (-n * m) + a;
			write_float_reg32(inst.rd, result);
		}
	} else {
		// f64
		double a = -(double)read_float_reg64(inst.ra);
		double n = -(double)read_float_reg64(inst.rn);
		double m = (double)read_float_reg64(inst.rm);

		if (inst.o0 == 0) {
			double result = (n * m) + a;
			write_float_reg64(inst.rd, result);
		} else {
			double result = (-n * m) + a;
			write_float_reg64(inst.rd, result);
		}
	}
}

execute(scvtf)
{
	if (inst.sf == 0) {
		if (inst.type == 0) {
			// 32-bit to sp
			write_float_reg32(inst.rd, (float)(sint32)read_gpr(0, inst.rn));
		} else if (inst.type == 1) {
			// 32-bit to dp
			write_float_reg64(inst.rd, (double)(sint32)read_gpr(0, inst.rn));
		}
	} else if (inst.sf == 1) {
		if (inst.type == 0) {
			// 64-bit to sp
			write_float_reg32(inst.rd, (float)(sint64)read_gpr(1, inst.rn));
		} else if (inst.type == 1) {
			// 64-bit to dp
			write_float_reg64(inst.rd, (double)(sint64)read_gpr(1, inst.rn));
		}
	}
	
}
execute(scvtf_simd)
{
	if (inst.size == 0) {
		// s32 -> f32
		write_float_reg32(inst.rd, (float)(sint32)read_vector_reg32(inst.rn));
	} else {
		// s64 -> f64
		write_float_reg64(inst.rd, (double)(sint64)read_vector_reg64(inst.rn));
	}
}

execute(ucvtf)
{
	if (inst.sf == 0) {
		if (inst.type == 0) {
			// 32-bit to sp
			write_float_reg32(inst.rd, (float)(uint32)read_gpr(0, inst.rn));
		} else if (inst.type == 1) {
			// 32-bit to dp
			write_float_reg64(inst.rd, (double)(uint32)read_gpr(0, inst.rn));
		}
	} else if (inst.sf == 1) {
		if (inst.type == 0) {
			// 64-bit to sp
			write_float_reg32(inst.rd, (float)(uint64)read_gpr(1, inst.rn));
		} else if (inst.type == 1) {
			// 64-bit to dp
			write_float_reg64(inst.rd, (double)(uint64)read_gpr(1, inst.rn));
		}
	}
}

execute(fcvtz)
{
	if (inst.opcode == 0) {
		// Signed
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to s32				
				write_gpr32(inst.rd, (uint32)(sint32)read_float_reg32(inst.rn));
			} else {
				// f64 to s32
				write_gpr32(inst.rd, (uint32)(sint32)read_float_reg64(inst.rn));
			}
		} else {
			if (inst.type == 0) {
				// f32 to s64
				write_gpr64(inst.rd, (uint64)(sint64)read_float_reg32(inst.rn));
			} else {
				// f64 to s64
				write_gpr64(inst.rd, (uint64)(sint64)read_float_reg64(inst.rn));
			}
		}
	} else {
		// Unsigned
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to u32
				write_gpr32(inst.rd, (uint32)read_float_reg32(inst.rn));
			} else {
				// f64 to u32
				write_gpr32(inst.rd, (uint32)read_float_reg64(inst.rn));
			}
		} else {
			if (inst.type == 0) {
				// f32 to u64
				write_gpr64(inst.rd, (uint64)read_float_reg32(inst.rn));
			} else {
				// f64 to u64
				write_gpr64(inst.rd, (uint64)read_float_reg64(inst.rn));
			}
		}
	}
}

execute(fcvti)
{
	if (inst.opcode == 0) {
		// Signed
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to s32				
				write_gpr32(inst.rd, __builtin_fcvt_f32_s32(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to s32
				write_gpr32(inst.rd, __builtin_fcvt_f64_s32(read_float_reg64(inst.rn), inst.rmode));
			}
		} else {
			if (inst.type == 0) {
				// f32 to s64
				write_gpr64(inst.rd, __builtin_fcvt_f32_s64(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to s64
				write_gpr64(inst.rd, __builtin_fcvt_f64_s64(read_float_reg64(inst.rn), inst.rmode));
			}
		}
	} else {
		// Unsigned
		if (inst.sf == 0) {
			if (inst.type == 0) {
				// f32 to u32
				write_gpr32(inst.rd, __builtin_fcvt_f32_u32(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to u32
				write_gpr32(inst.rd, __builtin_fcvt_f64_u32(read_float_reg64(inst.rn), inst.rmode));
			}
		} else {
			if (inst.type == 0) {
				// f32 to u64
				write_gpr64(inst.rd, __builtin_fcvt_f32_u64(read_float_reg32(inst.rn), inst.rmode));
			} else {
				// f64 to u64
				write_gpr64(inst.rd, __builtin_fcvt_f64_u64(read_float_reg64(inst.rn), inst.rmode));
			}
		}
	}
}

execute(fcvt)
{
	if (inst.type == 0) {
		// f32
		if (inst.opcode == 5) {
			// f32 -> f64
			write_float_reg64(inst.rd, (double)read_float_reg32(inst.rn));
		} else {
			trap();
		}
	} else if (inst.type == 1) {
		// f64
		if (inst.opcode == 4) {
			// f64 -> f32
			write_float_reg32(inst.rd, (float)read_float_reg64(inst.rn));
		} else {
			trap();
		}
	} else {
		trap();
	}
}

execute(frintx)
{
	uint8 rmode;
	switch (inst.opcode) {
	case 8: {
		rmode = 0;
		break;
	}
	case 9: {
		rmode = 1;
		break;
	}
	case 10: {
		rmode = 2;
		break;
	}
	case 11: {
		rmode = 3;
		break;
	}
	case 12: {
		rmode = 0;
		break;
	}
	case 14: {
		rmode = __builtin_get_fp_rounding();
		break;
	}
	case 15: {
		rmode = __builtin_get_fp_rounding();
		break;
	}
	default: {
		trap();
		break;
	}
	}

	if (inst.type == 0) {
		float v = read_float_reg32(inst.rn);
		write_float_reg32(inst.rd, __builtin_f32_round(v, rmode));
	} else {
		double v = read_float_reg64(inst.rn);
		write_float_reg64(inst.rd, __builtin_f64_round(v, rmode));
	}
}

execute(fsqrt)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, float_sqrt(read_float_reg32(inst.rn)));
	} else {
		write_float_reg64(inst.rd, double_sqrt(read_float_reg64(inst.rn)));
	}
}

execute(fabs)
{
	if (inst.type == 0) {
		write_float_reg32(inst.rd, __builtin_fabs32(read_float_reg32(inst.rn)));
	} else {
		write_float_reg64(inst.rd, __builtin_fabs64(read_float_reg64(inst.rn)));
	}
}

execute(fcmpe)
{
	if (inst.type == 0) {
		// f32
		float rn = read_float_reg32(inst.rn);
		float rm = (inst.opcode2 == 0x18 || inst.opcode2 == 0x08) ? (float)0 : read_float_reg32(inst.rm);
		
		if (inst.opcode & 0x10) {
			__builtin_cmpf32e_flags(rn, rm);
		} else {
			__builtin_cmpf32_flags(rn, rm);
		}
	} else {
		// f64
		double rn = read_float_reg64(inst.rn);
		double rm = (inst.opcode2 == 0x18 || inst.opcode2 == 0x08) ? (double)0 : read_float_reg64(inst.rm);
		
		if (inst.opcode & 0x10) {
			__builtin_cmpf64e_flags(rn, rm);
		} else {
			__builtin_cmpf64_flags(rn, rm);
		}
	}
}

execute(fccmpe)
{
	uint8 check = check_cond(inst.cond);
	
	if (check == 0) {
		write_register(N, (inst.nzcv & 8) == 8);
		write_register(Z, (inst.nzcv & 4) == 4);
		write_register(C, (inst.nzcv & 2) == 2);
		write_register(V, (inst.nzcv & 1) == 1);
	} else {
		if (inst.type == 0) {
			// f32
			float rn = read_float_reg32(inst.rn);
			float rm = read_float_reg32(inst.rm);
			__builtin_cmpf32_flags(rn, rm);
		} else {
			// f64
			double rn = read_float_reg64(inst.rn);
			double rm = read_float_reg64(inst.rm);
			__builtin_cmpf64_flags(rn, rm);
		}
	}
}

execute(ushr)
{
	if (inst.SCALAR) {
		write_vector_reg64(inst.rd, read_vector_reg64(inst.rd) >> inst.shift_amount);
	} else {
		trap();
	}
}

execute(movi)
{
	if (inst.Q == 0) {
		write_vector_reg64(inst.rd, inst.immu64);
	} else {
		write_vector_reg128(inst.rd, inst.immu64, inst.immu64);
	}
}

execute(fcsel)
{
	uint8 check = check_cond(inst.cond);
	
	if (check == 0) {
		if (inst.type == 0) {
			write_float_reg32(inst.rd, read_float_reg32(inst.rm));
		} else {
			write_float_reg64(inst.rd, read_float_reg64(inst.rm));
		}
	} else {
		if (inst.type == 0) {
			write_float_reg32(inst.rd, read_float_reg32(inst.rn));
		} else {
			write_float_reg64(inst.rd, read_float_reg64(inst.rn));
		}
	}
}

execute(fmovi)
{
	if (inst.type == 0) {
		write_vector_reg32(inst.rd, vfp_expand_imm32(inst.imm8));
	} else {
		write_vector_reg64(inst.rd, vfp_expand_imm64(inst.imm8));
	}
}

private helper float read_float_reg32(uint8 fr)
{
	return read_register_bank(FS, fr);
}

private helper double read_float_reg64(uint8 fr)
{
	return read_register_bank(FD, fr);
}

private helper void write_float_reg32(uint8 fr, float value)
{
	write_register_bank(FS, fr, value);
	write_register_bank(FSH, fr, 0);
	write_register_bank(VBH, fr, 0);
	return;
}

private helper void write_float_reg64(uint8 fr, double value)
{
	write_register_bank(FD, fr, value);
	write_register_bank(VBH, fr, 0);
	return;
}

private helper void write_vector_reg8(uint8 vr, uint8 value)
{
	write_register_bank(VBL, vr, (uint64)value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg16(uint8 vr, uint16 value)
{
	write_register_bank(VBL, vr, (uint64)value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg32(uint8 vr, uint32 value)
{
	write_register_bank(VBL, vr, (uint64)value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg64(uint8 vr, uint64 value)
{
	write_register_bank(VBL, vr, value);
	write_register_bank(VBH, vr, 0);
	return;
}

private helper void write_vector_reg128(uint8 vr, uint64 vl, uint64 vh)
{
	write_register_bank(VBL, vr, vl);
	write_register_bank(VBH, vr, vh);
	return;
}

private helper uint8 read_vector_reg8(uint8 vr)
{
	return read_register_bank(VB, vr);
}

private helper uint16 read_vector_reg16(uint8 vr)
{
	return read_register_bank(VH, vr);
}

private helper uint32 read_vector_reg32(uint8 vr)
{
	return read_register_bank(VS, vr);
}

private helper uint64 read_vector_reg64(uint8 vr)
{
	return read_register_bank(VD, vr);
}

private helper void read_vector_reg128(uint8 vr, uint64& vl, uint64& vh)
{
	vl = read_register_bank(VBL, vr);
	vh = read_register_bank(VBH, vr);
	return;
}

private helper uint32 vfp_expand_imm32(uint8 imm8)
{
	uint32 v = (uint32)imm8;

	uint32 sign = (v & 0x80) >> 7;
    uint32 exp = (!(v & 0x40)) << 7;
    exp |= (((v & 0x40) == 0) ? (uint32)0 : (uint32)0x7c);
    exp |= ((v & 0x30) >> 4);

    uint32 frac = (v & 0xf) << 19;
    return sign << 31 | exp << 23 | frac;
}

private helper uint64 vfp_expand_imm64(uint8 imm8)
{
	uint64 v = (uint64)imm8;

	uint64 sign = (v & 0x80) >> 7;
    uint64 exp = (!(v & 0x40)) << 10;
    exp |= (((v & 0x40) == 0) ? (uint64)0 : (uint64)0x3fc);
    exp |= ((v & 0x30) >> 4);

    uint64 frac = (v & 0xf) << 19;
    return sign << 63 | exp << 52 | frac;
}
