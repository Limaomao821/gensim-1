execute(movd) {
	uint64 op1 = read_operand_sse_scalar(inst.op1);
	write_operand_sse_scalar(inst.op0, op1);
}

execute(movdqu) {
	uint64[2] src = read_xmm_u64(inst.op1);
	write_xmm_u64(inst.op0, src);
}

execute(movq) {
	uint64 op1 = read_operand_sse_scalar(inst.op1);
	write_operand_sse_scalar(inst.op0, op1);
}

execute(movups) {
	uint64[2] src = read_xmm_u64(inst.op1);
	write_xmm_u64(inst.op0, src);
}

execute(paddd) {
	uint32[4] op0 = read_xmm_u32(inst.op0);
	uint32[4] op1 = read_xmm_u32(inst.op1);
	
	write_xmm_u32(inst.op0, op0 + op1);
}

execute(paddq) {
	uint64[2] op0 = read_xmm_u64(inst.op0);
	uint64[2] op1 = read_xmm_u64(inst.op1);
	
	write_xmm_u64(inst.op0, op0 + op1);
}

execute(pcmpeqb) {
	// figure out variant
	if(operand_get_size(inst.op0) == 64) {
		trap();
	} else {
		uint8[16] op0 = read_xmm_u8(inst.op0);
		uint8[16] op1 = read_xmm_u8(inst.op1);
		
		write_xmm_u8(inst.op0, op0 == op1);
	}
}

execute(pcmpgtw) {
	// figure out variant
	if(operand_get_size(inst.op0) == 64) {
		trap();
	} else {
		sint16[8] op0 = read_xmm_u16(inst.op0);
		sint16[8] op1 = read_xmm_u16(inst.op1);
		
		write_xmm_u16(inst.op0, op0 > op1);
	}
}

execute(pcmpgtd) {
	// figure out variant
	if(operand_get_size(inst.op0) == 64) {
		trap();
	} else {
		sint32[4] op0 = read_xmm_u32(inst.op0);
		sint32[4] op1 = read_xmm_u32(inst.op1);
		
		write_xmm_u32(inst.op0, op0 > op1);
	}
}

execute(por) {
	uint64[2] op0 = read_xmm_u64(inst.op0);
	uint64[2] op1 = read_xmm_u64(inst.op1);
	
	write_xmm_u64(inst.op0, op0 | op1);
}

execute(pmovmskb) {
	uint8[16] op1 = read_xmm_u8(inst.op1);
	uint32 output = 0;
	output |= op1[0] >> 7;
	output |= (op1[1] >> 7) << 1;
	output |= (op1[2] >> 7) << 2;
	output |= (op1[3] >> 7) << 3;
	output |= (op1[4] >> 7) << 4;
	output |= (op1[5] >> 7) << 5;
	output |= (op1[6] >> 7) << 6;
	output |= (op1[7] >> 7) << 7;
	output |= (op1[8] >> 7) << 8;
	output |= (op1[9] >> 7) << 9;
	output |= (op1[10] >> 7) << 10;
	output |= (op1[11] >> 7) << 11;
	output |= (op1[12] >> 7) << 12;
	output |= (op1[13] >> 7) << 13;
	output |= (op1[14] >> 7) << 14;
	output |= (op1[15] >> 7) << 15;
	
	write_operand(inst.op0, output);
}

execute(punpcklbw) {
	// figure out variant
	// (32 or 128 bit)
	if(operand_get_size(inst.op0) == 32) {
		trap();
	} else {
		uint8[16] op0 = read_xmm_u8(inst.op0);
		uint8[16] op1 = read_xmm_u8(inst.op1);
		
		uint8[16] dest;
		dest[0] = op0[0];
		dest[1] = op1[0];
		dest[2] = op0[1];
		dest[3] = op1[1];
		dest[4] = op0[2];
		dest[5] = op1[2];
		dest[6] = op0[3];
		dest[7] = op1[3];
		dest[8] = op0[4];
		dest[9] = op1[4];
		dest[10] = op0[5];
		dest[11] = op1[5];
		dest[12] = op0[6];
		dest[13] = op1[6];
		dest[14] = op0[7];
		dest[15] = op1[7];
		
		write_xmm_u8(inst.op0, dest);
	}
}

execute(punpcklwd) {
	// figure out variant
	// (32 or 128 bit)
	if(operand_get_size(inst.op0) == 32) {
		trap();
	} else {
		uint16[8] op0 = read_xmm_u16(inst.op0);
		uint16[8] op1 = read_xmm_u16(inst.op1);
		
		uint16[8] dest;
		dest[0] = op0[0];
		dest[1] = op1[0];
		dest[2] = op0[1];
		dest[3] = op1[1];
		dest[4] = op0[2];
		dest[5] = op1[2];
		dest[6] = op0[3];
		dest[7] = op1[3];
		write_xmm_u16(inst.op0, dest);
	}
}

execute(punpckldq) {
	// figure out variant
	// (32 or 128 bit)
	if(operand_get_size(inst.op0) == 32) {
		trap();
	} else {
		uint32[4] op0 = read_xmm_u32(inst.op0);
		uint32[4] op1 = read_xmm_u32(inst.op1);
		
		uint32[4] dest;
		dest[0] = op0[0];
		dest[1] = op1[0];
		dest[2] = op0[1];
		dest[3] = op1[1];
		
		write_xmm_u32(inst.op0, dest);
	}
}

execute(punpckhdq) {
	if(operand_get_size(inst.op0) == 64) {
		trap();
	} else {
		uint32[4] op0 = read_xmm_u32(inst.op0);
		uint32[4] op1 = read_xmm_u32(inst.op1);
		
		uint32[4] dest;
		dest[0] = op0[2];
		dest[1] = op1[2];
		dest[2] = op0[3];
		dest[3] = op1[3];
		
		write_xmm_u32(inst.op0, dest);
	}
}

execute(punpckhwd) {
	// figure out variant
	// (32 or 128 bit)
	if(operand_get_size(inst.op0) == 32) {
		trap();
	} else {
		uint16[8] op0 = read_xmm_u16(inst.op0);
		uint16[8] op1 = read_xmm_u16(inst.op1);
		
		uint16[8] dest;
		dest[0] = op0[4];
		dest[1] = op1[4];
		dest[2] = op0[5];
		dest[3] = op1[5];
		dest[4] = op0[6];
		dest[5] = op1[6];
		dest[6] = op0[7];
		dest[7] = op1[7];
		write_xmm_u16(inst.op0, dest);
	}
}

execute(punpcklqdq) {
	uint64[2] op0 = read_xmm_u64(inst.op0);
	uint64[2] op1 = read_xmm_u64(inst.op1);
	
	op0[1] = op1[0];
	write_xmm_u64(inst.op0, op0);
}

execute(pshufd) {
	// figure out variant
	if(operand_get_size(inst.op0) == 128) {
		uint32[4] op1 = read_xmm_u32(inst.op1);
		uint8 order = read_operand(inst.op2);
		
		uint32[4] dest;
		dest[0] = op1[order & 3];
		dest[1] = op1[(order >> 2) & 3];
		dest[2] = op1[(order >> 4) & 3];
		dest[3] = op1[(order >> 6) & 3];
		
		write_xmm_u32(inst.op0, dest);
		
	} else {
		trap();
	}
}

execute(pslld) {
	uint64 shift = read_operand(inst.op1);
	uint32[4] op = read_xmm_u32(inst.op0);
	
	write_xmm_u32(inst.op0, op << shift);
}

execute(pxor) {
	uint64[2] op0 = read_xmm_u64(inst.op0);
	uint64[2] op1 = read_xmm_u64(inst.op1);
	
	write_xmm_u64(inst.op0, op0 ^ op1);
}

helper uint8[16] read_xmm_u8(struct Operand &op)
{
	if(op.is_reg) {
		return read_register_bank(XMM_U8, op.reg.index);
	} else {
		trap();
	}
	return 0;
}

helper void write_xmm_u8(struct Operand &op, uint8[16] value)
{
	if(op.is_reg) {
		write_register_bank(XMM_U8, op.reg.index, value);
	} else {
		trap();
	}
	return;
}

helper uint16[8] read_xmm_u16(struct Operand &op)
{
	if(op.is_reg) {
		return read_register_bank(XMM_U16, op.reg.index);
	} else {
		trap();
	}
	return 0;
}

helper void write_xmm_u16(struct Operand &op, uint16[8] value)
{
	if(op.is_reg) {
		write_register_bank(XMM_U16, op.reg.index, value);
	} else {
		trap();
	}
	return;
}

helper uint32[4] read_xmm_u32(struct Operand &op)
{
	if(op.is_reg) {
		return read_register_bank(XMM_U32, op.reg.index);
	} else {
		trap();
	}
	return 0;
}

helper void write_xmm_u32(struct Operand &op, uint32[4] value)
{
	if(op.is_reg) {
		write_register_bank(XMM_U32, op.reg.index, value);
	} else {
		trap();
	}
	return;
}

helper uint64[2] read_xmm_u64(struct Operand &op)
{
	if(op.is_reg) {
		return read_register_bank(XMM_U64, op.reg.index);
	} else if(op.is_mem) {
		uint64 data;
		uint64 addr = mem_get_addr(op.memory);
		
		uint64[2] output;
		mem_read_64(Data, addr, data);
		output[0] = data;
		mem_read_64(Data, addr + 8, data);
		output[1] = data;
		
		return output;
		
	} else {
		trap();
	}
	return 0;
}

helper void write_xmm_u64(struct Operand &op, uint64[2] value)
{
	if(op.is_reg) {
		write_register_bank(XMM_U64, op.reg.index, value);
	} else if(op.is_mem) {
		uint64 addr = mem_get_addr(op.memory);
		
		mem_write_64(Data, addr, value[0]);
		mem_write_64(Data, addr+8, value[1]);
		
	} else {
		trap();
	}
	return;
}

helper uint64 read_operand_sse_scalar(struct Operand &op)
{
	if(op.is_reg) {
		if(op.reg.regclass == 0) {
			return read_op_reg(op.reg);
		} else {
			return read_op_reg_sse(op.reg);
		}
	} else if(op.is_imm) {
		return read_op_imm(op.imm);
	} else if(op.is_relbr) {
		return read_op_relbr(op.imm);
	} else if(op.is_mem) {
		return read_op_mem(op.memory);
	}
	trap();
	
	return 0;
}

helper uint64 read_op_reg_sse(struct Register &reg)
{
	switch(reg.regclass) {
		case 1: { //XMM
			uint64[2] vector = read_register_bank(XMM_U64, reg.index);
			return vector[0];
		}
		default: {
			trap();
			break;
		}
	}
	return 0;
}

helper void write_operand_sse_scalar(struct Operand &op, uint64 value)
{
	if(op.is_reg) {
		if(op.reg.regclass == 0) {
			write_op_reg(op.reg, value);
		} else {
			write_op_reg_sse(op.reg, value);
		}
		return;
	} else if(op.is_mem) {
		write_op_mem(op.memory, value);
		return;
	}
	trap();

	return;
}

helper void write_op_reg_sse(struct Register &reg, uint64 value)
{
	switch(reg.regclass) {
		case 1: { //XMM
			write_register_bank(XMM_U64L, reg.index, value);
			return;
		}
		default: {
			trap();
			break;
		}
	}
	return;
}
